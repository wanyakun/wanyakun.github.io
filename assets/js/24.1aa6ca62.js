(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{536:function(e,t,_){"use strict";_.r(t);var u=_(7),n=Object(u.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("首先，串行并行针对的是队列，同步异步针对的是任务；如果觉得队列和任务不太好理解咱们可以打个比方，假设一个应用程序是一个工厂，那队列就是里面的流水线以及线上的工人，而流水线上的工人所要处理的产品就是所谓的任务。")]),e._v(" "),_("p",[_("strong",[e._v("串行，并行")]),e._v("\n系统会给每个应用自动分配两个队列：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("dispatch_get_main_queue() 串行队列 处理UI，也可以叫串行主队列，这个队列会排在主线程中。")])]),e._v(" "),_("li",[_("p",[e._v("dispatch_get_global_queue(优先级, 扩展)并行队列。")])])]),e._v(" "),_("p",[e._v("当然根据需求也可以自己主动创建队dispatch_queue_create(队列标签, 串行／并行)。")]),e._v(" "),_("p",[e._v("注意：串行queue每次只能执行一个任务,可以使用它来代替锁,保护共享资源或可变的数据结构,串行queue确保任务按可预测的顺序执行(这是比锁好的地方)")]),e._v(" "),_("p",[_("strong",[e._v("同步和异步")]),e._v("\n 1. 异步调度 dispatch_async : 把一个任务添加到某queue后就马上离开,而不管任务在那个queue里的执行状态")]),e._v(" "),_("p",[e._v("2. 同步调度 dispatch_sync : 把一个任务添加到某queue后,等这个任务完成,调用线程才继续执行.")]),e._v(" "),_("p",[e._v("所以,异步调度和同步调度的区别不在于被添加的任务怎样执行,而在于调用线程是否等待任务执行完。")])])}),[],!1,null,null,null);t.default=n.exports}}]);