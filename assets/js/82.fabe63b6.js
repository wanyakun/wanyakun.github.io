(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{583:function(t,a,e){"use strict";e.r(a);var r=e(4),_=function(t){t.options.__data__block__={mermaid_382ee1aa:"graph LR\ntxt1(明文) -- 对称秘钥加密 --\x3e text[[密文]] -- 对称秘钥解密 --\x3e txt2(明文)\n",mermaid_382ee1c6:"graph LR\ntxt1(明文) -- 公钥加密 --\x3e text[[密文]] -- 私钥解密 --\x3e txt2(明文)\n",mermaid_382ee200:"graph LR\ntxt1(内容) -- SHA-2 --\x3e text[[df26814ef034a87ee780bfca7e45437ae82b128c]]\n",mermaid_382ee204:"graph LR\ntxt1(内容 + 摘要) -- 会话秘钥加密 --\x3e text[[密文]] -- 会话秘钥解密 --\x3e txt2(内容 + 摘要) -- 内容SHA-2 --\x3e txt3(摘要)\ntxt2(内容 + 摘要) -- 摘要对比 --\x3e txt3(摘要)\n",mermaid_382ee220:"graph LR\ntxt1(内容) -- SHA-2 --\x3e txt2[[摘要]] -- 对比 --\x3e txt3[[摘要]]\ntxt1(内容) -- SHA-2 --\x3e txt4[[摘要]] -- 私钥加密 --\x3e txt5[[数字签名]] -- 公钥解密 --\x3e txt3[[摘要]]\n",mermaid_382ee23f:"sequenceDiagram\nactor C as 客户端\nactor S as 服务器\nactor G as 数字认证机构\n\npar\nNote over C: 数字证书认证机构的公钥<br />已事先植入到浏览器里\nend\nS ->> G: 1. 服务器把自己的公开秘钥登录至数字证书认证机构\nNote over S: 服务器的公钥\nG --\x3e> S: 2. 数字证书认证机构用自己的私有密钥 <br />对服务器的公开密钥署数字签名并颁发公钥证书\nNote over G: 数字证书认证机构的私有密钥\nNote over S: 公钥证书：<br />服务器的公钥 + 数字证书认证机构的数字签名\nS ->> C: 公钥证书\npar\nNote over C: 3. 客户端拿到服务器的公钥证书后，使用<br />数字证书认证机构的公开秘钥，向数字证<br />书认证机构验证公钥证书上的数字签名，<br />以确认服务器的公开秘钥的真实性\nend\nC ->> S: 4: 使用服务器的公开秘钥对报文进行加密后发送\npar\nNote over S: 5. 服务器用私钥对报文解密\nend\n"}},v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"安全性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[t._v("#")]),t._v(" 安全性")]),t._v(" "),e("p",[t._v("HTTPS是建立在SSL之上，其安全性由SSL来保证"),e("br"),t._v("\n在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能")]),t._v(" "),e("blockquote",[e("p",[t._v("SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/front/network/https.png",alt:"https"}})]),t._v(" "),e("h2",{attrs:{id:"如何实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现"}},[t._v("#")]),t._v(" 如何实现")]),t._v(" "),e("p",[t._v("SSL的实现这些功能主要依赖于三种手段：")]),t._v(" "),e("ul",[e("li",[t._v("对称加密： 采用协商的秘钥对数据加密")]),t._v(" "),e("li",[t._v("非对称加密：实现身份认证和秘钥协商")]),t._v(" "),e("li",[t._v("摘要算法：验证信息的完整性")]),t._v(" "),e("li",[t._v("数字签名：身份验证")])]),t._v(" "),e("h3",{attrs:{id:"对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),e("p",[t._v("对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee1aa",graph:t.$dataBlock.mermaid_382ee1aa}}),e("h3",{attrs:{id:"非对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),e("p",[t._v("非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密"),e("br"),t._v("\n公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee1c6",graph:t.$dataBlock.mermaid_382ee1c6}}),e("h3",{attrs:{id:"对称加密-非对称加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称加密-非对称加密"}},[t._v("#")]),t._v(" 对称加密 + 非对称加密")]),t._v(" "),e("p",[t._v("在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密"),e("br"),t._v("\n在对称加密中，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性"),e("br"),t._v("\n而HTTPS采用非对称加密解决秘钥交换的问题"),e("br"),t._v("\n具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信")]),t._v(" "),e("p",[t._v("这种方法解决了数据加密，但在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客截获"),e("br"),t._v("\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法")]),t._v(" "),e("h3",{attrs:{id:"摘要算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#摘要算法"}},[t._v("#")]),t._v(" 摘要算法")]),t._v(" "),e("p",[t._v("实现完整性校验的手段主要是摘要算法，也就是常说的散列函数、哈希函数"),e("br"),t._v("\n可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee200",graph:t.$dataBlock.mermaid_382ee200}}),e("p",[t._v("摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee204",graph:t.$dataBlock.mermaid_382ee204}}),e("h3",{attrs:{id:"数字签名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[t._v("#")]),t._v(" 数字签名")]),t._v(" "),e("p",[t._v("数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名"),e("br"),t._v("\n原理其实很简单，就是用私钥加密，公钥解密"),e("br"),t._v("\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee220",graph:t.$dataBlock.mermaid_382ee220}}),e("p",[t._v("和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥"),e("br"),t._v("\n这时候就需要一个第三方，就是证书验证机构")]),t._v(" "),e("h3",{attrs:{id:"ca验证机构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ca验证机构"}},[t._v("#")]),t._v(" CA验证机构")]),t._v(" "),e("p",[t._v("数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场"),e("br"),t._v("\nCA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”")]),t._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee23f",graph:t.$dataBlock.mermaid_382ee23f}}),e("ul",[e("li",[t._v("服务器的运营人员向数字证书认证机构提出公开密钥的申请")]),t._v(" "),e("li",[t._v("数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名")]),t._v(" "),e("li",[t._v("然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起")]),t._v(" "),e("li",[t._v("服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信")])]),t._v(" "),e("p",[t._v("接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：")]),t._v(" "),e("ul",[e("li",[t._v("认证服务器的公开密钥的是真实有效的数字证书认证机构")]),t._v(" "),e("li",[t._v("服务器的公开密钥是值得信赖的")])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：")]),t._v(" "),e("ul",[e("li",[t._v("机密性：混合算法")]),t._v(" "),e("li",[t._v("完整性：摘要算法")]),t._v(" "),e("li",[t._v("身份认证：数字签名")]),t._v(" "),e("li",[t._v("不可否定：数字签名")])]),t._v(" "),e("p",[t._v("同时引入第三方证书机构，确保公开秘钥的安全性")])],1)}),[],!1,null,null,null);"function"==typeof _&&_(v);a.default=v.exports}}]);