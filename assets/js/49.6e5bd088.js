(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{529:function(l,_,c){"use strict";c.r(_);var o=c(7),t=Object(o.a)({},(function(){var l=this,_=l.$createElement,c=l._self._c||_;return c("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[c("h2",{attrs:{id:"block的结构体"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#block的结构体"}},[l._v("#")]),l._v(" Block的结构体")]),l._v(" "),c("p",[l._v("block结构体包括以下内容：")]),l._v(" "),c("ul",[c("li",[l._v("block_impl")]),l._v(" "),c("li",[l._v("block_desc")]),l._v(" "),c("li",[l._v("复制的外部变量")]),l._v(" "),c("li",[l._v("构造函数")])]),l._v(" "),c("h3",{attrs:{id:"一、block-impl-包括内容"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#一、block-impl-包括内容"}},[l._v("#")]),l._v(" 一、block_impl 包括内容")]),l._v(" "),c("ul",[c("li",[l._v("isa 表示block是一个对象")]),l._v(" "),c("li",[l._v("Flags 标志位，还不知道干啥用")]),l._v(" "),c("li",[l._v("FuncPtr 函数指针block_func，封装block代码的函数")]),l._v(" "),c("li",[l._v("Reserved 保留位")])]),l._v(" "),c("h3",{attrs:{id:"二、block-desc记录block的大小、copy和dispose方法"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#二、block-desc记录block的大小、copy和dispose方法"}},[l._v("#")]),l._v(" 二、block_desc记录block的大小、copy和dispose方法")]),l._v(" "),c("ul",[c("li",[l._v("reserve")]),l._v(" "),c("li",[l._v("size")]),l._v(" "),c("li",[l._v("copy")]),l._v(" "),c("li",[l._v("dispose")])]),l._v(" "),c("h2",{attrs:{id:"变量捕捉"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#变量捕捉"}},[l._v("#")]),l._v(" 变量捕捉")]),l._v(" "),c("p",[l._v("所谓的捕获外部变量，就是在block内部创建外部对应的变量。"),c("br"),l._v("\n全局变量整个项目都可以使用，所以block不用担心变量被释放，使用的时候直接访问。"),c("br"),l._v("\n局部变量有作用域，如果block调用的时候已经被释放，则会出现问题，所以需要捕获，在block内部创建对应的变量。")]),l._v(" "),c("h3",{attrs:{id:"一、全局变量"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#一、全局变量"}},[l._v("#")]),l._v(" 一、全局变量")]),l._v(" "),c("p",[l._v("不捕获，也就是内部不创建对应的变量。可以直接访问改变全局变量")]),l._v(" "),c("h3",{attrs:{id:"二、局部变量"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#二、局部变量"}},[l._v("#")]),l._v(" 二、局部变量")]),l._v(" "),c("p",[c("strong",[l._v("auto变量：")]),l._v(" 捕获，block结构体中创建对应的变量，将外部的值赋值给block内部对应的变量，属于值传递，block内部存在的是block内部创建的变量，所以在block内部不能够修改block外部变量的内容。（外部对象变量，传递的是变量是指针的地址，即栈中的地址，所以也是不可以改变的）"),c("br"),l._v(" "),c("strong",[l._v("静态变量：")]),l._v(" 捕获，指针传递，因为静态变量的存储区域也在全局存储区，但可能有多个名称相同的静态变量存在，所以需要用地址访问。block内部可以修改静态变量的值")]),l._v(" "),c("h2",{attrs:{id:"block的类型"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#block的类型"}},[l._v("#")]),l._v(" Block的类型")]),l._v(" "),c("ol",[c("li",[l._v("__NSGlobalBlock__block没有访问auto变量，内存区域为数据段")]),l._v(" "),c("li",[l._v("__NSStackBlock__block访问了auto变量，内存区域为栈")]),l._v(" "),c("li",[l._v("__NSMallocBlock__block调用了copy方法，内存区域为堆")])]),l._v(" "),c("h2",{attrs:{id:"block的复制操作"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#block的复制操作"}},[l._v("#")]),l._v(" Block的复制操作")])])}),[],!1,null,null,null);_.default=t.exports}}]);